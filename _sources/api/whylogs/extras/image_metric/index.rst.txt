:py:mod:`whylogs.extras.image_metric`
=====================================

.. py:module:: whylogs.extras.image_metric


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   whylogs.extras.image_metric.ImageSubmetricSchema
   whylogs.extras.image_metric.ImageMetricConfig
   whylogs.extras.image_metric.ImageMetric



Functions
~~~~~~~~~

.. autoapisummary::

   whylogs.extras.image_metric.get_pil_image_statistics
   whylogs.extras.image_metric.get_pil_exif_metadata
   whylogs.extras.image_metric.image_based_metadata
   whylogs.extras.image_metric.get_pil_image_metadata
   whylogs.extras.image_metric.init_image_schema
   whylogs.extras.image_metric.log_image



Attributes
~~~~~~~~~~

.. autoapisummary::

   whylogs.extras.image_metric.logger
   whylogs.extras.image_metric.ImageType
   whylogs.extras.image_metric.DEFAULT_IMAGE_FEATURES
   whylogs.extras.image_metric.tmp


.. py:data:: logger

   

.. py:data:: ImageType

   

.. py:data:: DEFAULT_IMAGE_FEATURES
   :type: List[str]
   :value: []

   

.. py:function:: get_pil_image_statistics(img: PIL.Image.Image, channels: List[str] = _IMAGE_HSV_CHANNELS, image_stats: List[str] = _STATS_PROPERTIES) -> Dict

   Compute statistics data for a PIL Image

   :param img: PIL Image
   :type img: ImageType

   :returns: of metadata
   :rtype: Dict


.. py:function:: get_pil_exif_metadata(img: PIL.Image.Image) -> Dict

   Grab EXIF metadata from image

   :param img: PIL Image
   :type img: ImageType

   :returns: of metadata
   :rtype: Dict


.. py:function:: image_based_metadata(img: PIL.Image.Image) -> Dict[str, int]


.. py:function:: get_pil_image_metadata(img: PIL.Image.Image) -> Dict

   Grab statistics data from a PIL ImageStats.Stat

   :param img: PIL Image
   :type img: ImageType

   :returns: of metadata
   :rtype: Dict


.. py:class:: ImageSubmetricSchema

   Bases: :py:obj:`whylogs.core.metrics.multimetric.SubmetricSchema`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:method:: resolve(name: str, why_type: whylogs.core.datatypes.DataType, fi_disabled: bool = False) -> Dict[str, whylogs.core.metrics.metrics.Metric]



.. py:class:: ImageMetricConfig

   Bases: :py:obj:`whylogs.core.metrics.metrics.MetricConfig`

   .. py:attribute:: allowed_exif_tags
      :type: Set[str]

      

   .. py:attribute:: forbidden_exif_tags
      :type: Set[str]

      

   .. py:attribute:: hll_lg_k
      :type: int

      

   .. py:attribute:: kll_k
      :type: int

      

   .. py:attribute:: fi_lg_max_k
      :type: int

      

   .. py:attribute:: fi_disabled
      :type: bool

      

   .. py:attribute:: track_unicode_ranges
      :type: bool

      

   .. py:attribute:: large_kll_k
      :type: bool

      

   .. py:attribute:: kll_k_large
      :type: int

      

   .. py:attribute:: unicode_ranges
      :type: Dict[str, Tuple[int, int]]

      

   .. py:attribute:: lower_case
      :type: bool

      

   .. py:attribute:: normalize
      :type: bool

      

   .. py:attribute:: max_frequent_item_size
      :type: int

      

   .. py:attribute:: identity_column
      :type: Optional[str]

      


.. py:class:: ImageMetric(submetrics: Dict[str, Dict[str, whylogs.core.metrics.metrics.Metric]], allowed_exif_tags: Optional[Set[str]] = None, forbidden_exif_tags: Optional[Set[str]] = None, submetric_schema: Optional[whylogs.core.metrics.multimetric.SubmetricSchema] = None, type_mapper: Optional[whylogs.core.datatypes.TypeMapper] = None, fi_disabled: bool = False)

   Bases: :py:obj:`whylogs.core.metrics.multimetric.MultiMetric`

   MultiMetric serves as a base class for custom metrics that consist
   of one or more metrics. It is handy when you need to do some
   processing of the logged values and track several metrics on
   the results. The sub-metrics must either be a StandardMetric, or tagged
   as a @custom_metric or registered via register_metric(). Note that
   MultiMetric is neither, so it cannot be nested.

   Typically you will need to override namespace(); columnar_update(), calling
   it on the submetrics as needed; and the zero() method to return an
   appropriate "empty" instance of your metric. You will need to override from_protobuf()
   and merge() if your subclass __init__() method takes arguments different than
   MultiMetrtic's. You can use the submetrics_from_protbuf() and merge_submetrics()
   helper methods to implement them. The MultiMetric class will handle the rest of
   the Metric interface. Don't use / or : in the subclass' namespace.

   See UnicodeRangeMetric for an example.

   .. py:property:: namespace
      :type: str


   .. py:property:: exclude_from_serialization
      :type: bool


   .. py:attribute:: submetrics
      :type: Dict[str, Dict[str, whylogs.core.metrics.Metric]]

      

   .. py:method:: merge(other: ImageMetric) -> ImageMetric


   .. py:method:: columnar_update(view: whylogs.core.preprocessing.PreprocessedColumn) -> whylogs.core.metrics.metrics.OperationResult


   .. py:method:: zero(config: Optional[whylogs.core.metrics.metrics.MetricConfig] = None) -> ImageMetric
      :classmethod:


   .. py:method:: merge_submetrics(other: MULTI_METRIC) -> Dict[str, Dict[str, whylogs.core.metrics.Metric]]


   .. py:method:: to_protobuf() -> whylogs.core.proto.MetricMessage


   .. py:method:: get_component_paths() -> List[str]


   .. py:method:: to_summary_dict(cfg: Optional[whylogs.core.configs.SummaryConfig] = None) -> Dict[str, Any]


   .. py:method:: submetrics_from_protobuf(msg: whylogs.core.proto.MetricMessage) -> Dict[str, Dict[str, whylogs.core.metrics.Metric]]
      :classmethod:


   .. py:method:: from_protobuf(msg: whylogs.core.proto.MetricMessage) -> MULTI_METRIC
      :classmethod:


   .. py:method:: get_namespace(config: Optional[MetricConfig] = None) -> str
      :classmethod:



.. py:function:: init_image_schema(column_prefix: str = 'image') -> whylogs.core.schema.DatasetSchema

   Initialize a DatasetSchema for logging images. This can be passed into a logger or why.log.

   :param column_prefix: The prefix that appears in the dataset profiles along with all of the
   :type column_prefix: str
   :param image features. If the prefix is "image": image_data}).
   :param then you'll log image with why.log({image: image_data}).


.. py:function:: log_image(images: Union[PIL.Image.Image, List[PIL.Image.Image], Dict[str, PIL.Image.Image]], default_column_prefix: str = 'image', schema: Optional[whylogs.core.schema.DatasetSchema] = None, trace_id: Optional[str] = None) -> whylogs.api.logger.result_set.ResultSet


.. py:data:: tmp

   

