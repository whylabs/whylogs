:py:mod:`whylogs.core.constraints.factories`
============================================

.. py:module:: whylogs.core.constraints.factories


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   cardinality_metrics/index.rst
   condition_counts/index.rst
   count_metrics/index.rst
   distribution_metrics/index.rst
   frequent_items/index.rst
   multi_metrics/index.rst
   types_metrics/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   whylogs.core.constraints.factories.distinct_number_in_range
   whylogs.core.constraints.factories.condition_meets
   whylogs.core.constraints.factories.condition_never_meets
   whylogs.core.constraints.factories.count_below_number
   whylogs.core.constraints.factories.no_missing_values
   whylogs.core.constraints.factories.null_percentage_below_number
   whylogs.core.constraints.factories.null_values_below_number
   whylogs.core.constraints.factories.greater_than_number
   whylogs.core.constraints.factories.is_in_range
   whylogs.core.constraints.factories.is_non_negative
   whylogs.core.constraints.factories.mean_between_range
   whylogs.core.constraints.factories.quantile_between_range
   whylogs.core.constraints.factories.smaller_than_number
   whylogs.core.constraints.factories.stddev_between_range
   whylogs.core.constraints.factories.frequent_strings_in_reference_set
   whylogs.core.constraints.factories.n_most_common_items_in_set
   whylogs.core.constraints.factories.column_is_probably_unique
   whylogs.core.constraints.factories.column_has_non_zero_types
   whylogs.core.constraints.factories.column_has_zero_count_types
   whylogs.core.constraints.factories.column_is_nullable_boolean
   whylogs.core.constraints.factories.column_is_nullable_datatype
   whylogs.core.constraints.factories.column_is_nullable_fractional
   whylogs.core.constraints.factories.column_is_nullable_integral
   whylogs.core.constraints.factories.column_is_nullable_object
   whylogs.core.constraints.factories.column_is_nullable_string



Attributes
~~~~~~~~~~

.. autoapisummary::

   whylogs.core.constraints.factories.ALL


.. py:function:: distinct_number_in_range(column_name: str, lower: Union[int, float], upper: Union[int, float]) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Number of distinct categories must be between lower and upper values (inclusive).

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param lower: Lower bound of defined range
   :type lower: int
   :param upper: Upper bound of the value range
   :type upper: int


.. py:function:: condition_meets(column_name: str, condition_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Checks that all values in column match predicate

   :param column_name: Name of the column to apply the constraint to
   :type column_name: str
   :param condition_name: Name of the condition that will be applied to each value of the column
   :type condition_name: str


.. py:function:: condition_never_meets(column_name: str, condition_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Checks that no values in column match predicate

   :param column_name: Name of the column to apply the constraint to
   :type column_name: str
   :param condition_name: Name of the condition that will be applied to each value of the column
   :type condition_name: str


.. py:function:: count_below_number(column_name: str, number: int) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Number of elements in a column must be below given number.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param number: reference value for applying the constraint
   :type number: float


.. py:function:: no_missing_values(column_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Checks that there are no missing values in the column.

   :param column_name: Column the constraint is applied to
   :type column_name: str


.. py:function:: null_percentage_below_number(column_name: str, number: float) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Percentage of null values must be below given number.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param number: reference value for applying the constraint
   :type number: float


.. py:function:: null_values_below_number(column_name: str, number: int) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Number of null values must be below given number.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param number: reference value for applying the constraint
   :type number: float


.. py:function:: greater_than_number(column_name: str, number: Union[float, int], skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Minimum value of given column must be above defined number.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param number: reference value for applying the constraint
   :type number: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: is_in_range(column_name: str, lower: Union[float, int], upper: Union[float, int], skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Checks that all of column's values are in defined range (inclusive).

   For the constraint to pass, the column's minimum value should be higher or equal than `lower` and maximum value should be less than or equal to `upper`.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param lower: lower bound of defined range
   :type lower: float
   :param upper: upper bound of defined range
   :type upper: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: is_non_negative(column_name: str, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Checks if a column is non negative

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: mean_between_range(column_name: str, lower: float, upper: float, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Estimated mean must be between range defined by lower and upper bounds.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param lower: Lower bound of defined range
   :type lower: int
   :param upper: Upper bound of the value range
   :type upper: int
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: quantile_between_range(column_name: str, quantile: float, lower: float, upper: float, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Q-th quantile value must be withing the range defined by lower and upper boundaries.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param quantile: Quantile value. E.g. median is equal to quantile_value=0.5
   :type quantile: float
   :param lower: Lower bound of defined range
   :type lower: float
   :param upper: Upper bound of the value range
   :type upper: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: smaller_than_number(column_name: str, number: float, skip_missing: bool = True) -> whylogs.core.constraints.MetricConstraint

   Maximum value of given column must be below defined number.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param number: reference value for applying the constraint
   :type number: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: stddev_between_range(column_name: str, lower: float, upper: float, skip_missing: bool = True)

   Estimated standard deviation must be between range defined by lower and upper bounds.

   :param column_name: Column the constraint is applied to
   :type column_name: str
   :param lower: Lower bound of defined range
   :type lower: float
   :param upper: Upper bound of the value range
   :type upper: float
   :param skip_missing: If skip_missing is True, missing distribution metrics will make the check pass.
                        If False, the check will fail on missing metrics, such as on an empty dataset
   :type skip_missing: bool


.. py:function:: frequent_strings_in_reference_set(column_name: str, reference_set: dict) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Determine whether a set of variables appear in the frequent strings for a string column.
   Every item in frequent strings must be in defined reference set

   :param column_name: Columns the constraint is applied to.
   :type column_name: str
   :param reference_set: Reference set for applying the constraint
   :type reference_set: dict


.. py:function:: n_most_common_items_in_set(column_name: str, n: int, reference_set: dict) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Validate if the top n most common items appear in the dataset.

   :param column_name: Columns the constraint is applied to.
   :type column_name: str
   :param n: n most common items or strings.
   :type n: int
   :param reference_set: Reference set for applying the constraint
   :type reference_set: dict


.. py:function:: column_is_probably_unique(column_name: str) -> whylogs.core.constraints.MetricConstraint


.. py:function:: column_has_non_zero_types(column_name: str, types_list: List[str]) -> whylogs.core.constraints.metric_constraints.MetricConstraint


.. py:function:: column_has_zero_count_types(column_name: str, types_list: List[str]) -> whylogs.core.constraints.metric_constraints.MetricConstraint


.. py:function:: column_is_nullable_boolean(column_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint


.. py:function:: column_is_nullable_datatype(column_name: str, datatype: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint

   Check if column contains only records of specific datatype.
   Datatypes can be: integral, fractional, boolean, string, object.

   Returns True if there is at least one record of type datatype and there is no records of remaining types.

   :param column_name: Column the constraint is applied to
   :type column_name: str


.. py:function:: column_is_nullable_fractional(column_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint


.. py:function:: column_is_nullable_integral(column_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint


.. py:function:: column_is_nullable_object(column_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint


.. py:function:: column_is_nullable_string(column_name: str) -> whylogs.core.constraints.metric_constraints.MetricConstraint


.. py:data:: ALL

   

