:py:mod:`whylogs.experimental.core.udf_schema`
==============================================

.. py:module:: whylogs.experimental.core.udf_schema


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   whylogs.experimental.core.udf_schema.UdfSpec
   whylogs.experimental.core.udf_schema.UdfSchema



Functions
~~~~~~~~~

.. autoapisummary::

   whylogs.experimental.core.udf_schema.register_dataset_udf
   whylogs.experimental.core.udf_schema.generate_udf_specs
   whylogs.experimental.core.udf_schema.udf_schema



Attributes
~~~~~~~~~~

.. autoapisummary::

   whylogs.experimental.core.udf_schema.logger


.. py:data:: logger

   

.. py:class:: UdfSpec

   Defines UDFs to apply to matching input columns. Tthe UDF is
   passed a dictionary or dataframe with the named columns available (the UDF will
   not be called unless all the named columns are available). The new column name
   the key in the udfs dictionary.

   .. py:attribute:: column_names
      :type: List[str]

      

   .. py:attribute:: udfs
      :type: Dict[str, Callable[[Any], Any]]

      


.. py:class:: UdfSchema(resolvers: List[whylogs.core.resolvers.ResolverSpec], types: Optional[Dict[str, Any]] = None, default_config: Optional[whylogs.core.metrics.metrics.MetricConfig] = None, type_mapper: Optional[whylogs.core.datatypes.TypeMapper] = None, cache_size: int = 1024, schema_based_automerge: bool = False, segments: Optional[Dict[str, whylogs.core.segmentation_partition.SegmentationPartition]] = None, validators: Optional[Dict[str, List[whylogs.core.validators.validator.Validator]]] = None, udf_specs: Optional[List[UdfSpec]] = None)

   Bases: :py:obj:`whylogs.core.schema.DeclarativeSchema`

   Subclass of DeclarativeSchema that runs the UDFs specified in udf_specs to
   create new columns before resolving metrics.

   .. py:method:: copy() -> whylogs.core.schema.DatasetSchema

      Returns a new instance of the same underlying schema


   .. py:method:: apply_udfs(pandas: Optional[whylogs.core.stubs.pd.DataFrame] = None, row: Optional[Dict[str, Any]] = None) -> Tuple[Optional[whylogs.core.stubs.pd.DataFrame], Optional[Mapping[str, Any]]]


   .. py:method:: add_resolver(resolver_spec: whylogs.core.resolvers.ResolverSpec)


   .. py:method:: add_resolver_spec(column_name: Optional[str] = None, column_type: Optional[Any] = None, metrics: Optional[List[whylogs.core.resolvers.MetricSpec]] = None)


   .. py:method:: resolve(*, pandas: Optional[whylogs.core.stubs.pd.DataFrame] = None, row: Optional[Mapping[str, Any]] = None) -> bool


   .. py:method:: get_col_names() -> tuple


   .. py:method:: get(name: str) -> Optional[ColumnSchema]



.. py:function:: register_dataset_udf(col_names: List[str], udf_name: Optional[str] = None, metrics: Optional[List[whylogs.core.resolvers.MetricSpec]] = None, namespace: Optional[str] = None, schema_name: str = '', anti_metrics: Optional[List[whylogs.core.metrics.metrics.Metric]] = None) -> Callable[[Any], Any]

   Decorator to easily configure UDFs for your data set. Decorate your UDF
   functions, then call generate_udf_dataset_schema() to create a UdfSchema
   that includes the UDFs configured by your decorator parameters. The decorated
   function will automatically be a UDF in the UdfSchema.

   Specify udf_name to give the output of the UDF a name. udf_name
   defautls to the name of the decorated function. Note that all lambdas are
   named "lambda", so omitting udf_name on more than one lambda will result
   in name collisions. If you pass a namespace, it will be prepended to the UDF name.
   Specifying schema_name will register the UDF in a particular schema. If omitted,
   it will be registered to the defualt schema.

   If any metrics are passed via the metrics argument, they will be attached
   to the column produced by the UDF via the schema returned by generate_udf_dataset_schema().
   If metrics is None, the UDF output column will get the metrics determined by
   the other resolvers passed to generate_udf_dataset_schema(), or the STANDARD_UDF_RESOLVER
   by default. Any anti_metrics will be excluded from the metrics attached to the UDF output.


.. py:function:: generate_udf_specs(other_udf_specs: Optional[List[UdfSpec]] = None, schema_name: Union[str, List[str]] = '', include_default_schema: bool = True) -> List[UdfSpec]

   Generates a list UdfSpecs that implement the UDFs specified
   by the @register_dataset_udf decorators. You can provide a list of
   other_udf_specs to include in addition to those UDFs registered via
   the decorator.

   For example:

   @register_dataset_udf(col_names=["col1"])
   def add5(x):
       return x + 5

   schema = UdfSchema(STANDARD_RESOLVER, udf_specs=generate_udf_specs())
   why.log(data, schema=schema)

   This will attach a UDF to column "col1" that will generate a new column
   named "add5" containing the values in "col1" incremented by 5. Since these
   are appended to the STANDARD_UDF_RESOLVER, the default metrics are also tracked
   for every column.


.. py:function:: udf_schema(other_udf_specs: Optional[List[UdfSpec]] = None, resolvers: Optional[List[whylogs.core.resolvers.ResolverSpec]] = None, types: Optional[Dict[str, Any]] = None, default_config: Optional[whylogs.core.metrics.metrics.MetricConfig] = None, type_mapper: Optional[whylogs.core.datatypes.TypeMapper] = None, cache_size: int = 1024, schema_based_automerge: bool = False, segments: Optional[Dict[str, whylogs.core.segmentation_partition.SegmentationPartition]] = None, validators: Optional[Dict[str, List[whylogs.core.validators.validator.Validator]]] = None, schema_name: Union[str, List[str]] = '', include_default_schema: bool = True) -> UdfSchema

   Returns a UdfSchema that implements any registered UDFs, along with any
   other_udf_specs or resolvers passed in.


