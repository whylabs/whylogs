:py:mod:`whylogs.api.logger.experimental.logger.actor.process_actor`
====================================================================

.. py:module:: whylogs.api.logger.experimental.logger.actor.process_actor


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   whylogs.api.logger.experimental.logger.actor.process_actor.QueueType
   whylogs.api.logger.experimental.logger.actor.process_actor.ProcessActor




Attributes
~~~~~~~~~~

.. autoapisummary::

   whylogs.api.logger.experimental.logger.actor.process_actor.StatusType
   whylogs.api.logger.experimental.logger.actor.process_actor.ProcessMessageType


.. py:data:: StatusType

   

.. py:data:: ProcessMessageType

   

.. py:class:: QueueType

   Bases: :py:obj:`enum.Enum`

   Generic enumeration.

   Derive from this class to define new enumerations.

   .. py:attribute:: MP
      :value: 'MP'

      

   .. py:attribute:: FASTER_FIFO
      :value: 'FASTER_FIFO'

      

   .. py:method:: name()

      The name of the Enum member.


   .. py:method:: value()

      The value of the Enum member.



.. py:class:: ProcessActor(queue_config: whylogs.api.logger.experimental.logger.actor.actor.QueueConfig = QueueConfig(), queue_type: QueueType = QueueType.FASTER_FIFO, sync_enabled: bool = False)

   Bases: :py:obj:`whylogs.api.logger.experimental.logger.actor.actor.Actor`\ [\ :py:obj:`Union`\ [\ :py:obj:`ProcessMessageType`\ , :py:obj:`whylogs.api.logger.experimental.logger.actor.process_rolling_logger_messages.ProcessStatusMessage`\ ]\ ], :py:obj:`multiprocessing.Process`, :py:obj:`Generic`\ [\ :py:obj:`ProcessMessageType`\ , :py:obj:`StatusType`\ ]

   Subclass of Actor that uses a process to process messages.

   .. py:property:: name


   .. py:property:: daemon

      Return whether process is a daemon

   .. py:property:: authkey


   .. py:property:: exitcode

      Return exit code of process or `None` if it has yet to stop

   .. py:property:: ident

      Return identifier (PID) of process or `None` if it has yet to start

   .. py:property:: sentinel

      Return a file descriptor (Unix) or handle (Windows) suitable for
      waiting for process termination.

   .. py:attribute:: pid

      

   .. py:method:: close_message_handled() -> bool


   .. py:method:: set_close_message_handled() -> None


   .. py:method:: close_message_wait() -> None


   .. py:method:: is_done() -> bool


   .. py:method:: done_wait() -> None


   .. py:method:: set_done() -> None

      Set this actor as done, meaning it has finished processing all messages.


   .. py:method:: set_closed() -> None

      Sets this actor as closed, meaning it should no longer accept messages.


   .. py:method:: is_closed() -> bool


   .. py:method:: close() -> None

      Close the Process object.

      This method releases resources held by the Process object.  It is
      an error to call this method if the child process is still running.


   .. py:method:: status(timeout: Optional[float] = 1.0) -> StatusType

      Get the internal status of the Process Actor. Used for diagnostics and debugging.
      This is always synchronous and requires the ProcessActor to be created with sync_enabled=True.


   .. py:method:: run() -> None

      Method to be run in sub-process; can be overridden in sub-class


   .. py:method:: start() -> None

      The process version of the actor apparently has to be manually started after
      it's created, unlike the thread version which can just be automatically started
      from within its init. There must be some post-init setup that needs to be done.


   .. py:method:: process_batch(batch: List[Union[MessageType, CloseMessage]], batch_type: Type[Union[MessageType, CloseMessage]]) -> None
      :abstractmethod:


   .. py:method:: send(message: Union[MessageType, CloseMessage]) -> None


   .. py:method:: send_many(messages: List[Union[MessageType, CloseMessage]]) -> None


   .. py:method:: process_messages() -> None


   .. py:method:: terminate()

      Terminate process; sends SIGTERM signal or uses TerminateProcess()


   .. py:method:: kill()

      Terminate process; sends SIGKILL signal or uses TerminateProcess()


   .. py:method:: join(timeout=None)

      Wait until child process terminates


   .. py:method:: is_alive()

      Return whether process is alive



